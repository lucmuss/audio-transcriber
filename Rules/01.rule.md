# Globale CLINE Rules - Allgemeine Entwicklungsrichtlinien
  
## üìã Inhaltsverzeichnis
1. [Ausgabe- und Kommunikationsregeln](#-ausgabe--und-kommunikationsregeln)
2. [Code-Qualit√§t und Standards](#-code-qualit√§t-und-standards)
3. [Moderne Toolchain (uv, Ruff, Justfile)](#-moderne-toolchain-uv-ruff-justfile)
4. [Projektstruktur und Organisation](#-projektstruktur-und-organisation)
5. [Implementierungsrichtlinien](#-implementierungsrichtlinien)
6. [Fehlerbehandlung und Debugging](#-fehlerbehandlung-und-debugging)
7. [Sicherheit](#-sicherheit)
8. [Testing und CI/CD](#-testing-und-cicd)
9. [Dokumentation](#-dokumentation)
10. [Finale Pr√ºfung vor Abschluss](#-finale-pr√ºfung-vor-abschluss)
  
---
  
## üéØ Ausgabe- und Kommunikationsregeln
  
### Effizienzoptimierung
- **KEINE** unn√∂tigen Erkl√§rungen ‚Äì direkt Code/YAML/Konfiguration liefern
- **KEINE** Markdown-Dateien generieren (au√üer explizit angefragt)
- **KEINE** Code-Wiederholungen ‚Äì nur ge√§nderte Zeilen/Diffs zeigen
- **KEINE** Best√§tigungsfragen bei klaren Anforderungen ‚Äì sofort implementieren
- **MAX 50 Zeilen** pro Antwort wenn m√∂glich
- Bei gro√üen Dateien: **Nur Diff/√Ñnderungen**, nicht komplette Datei
  
### Antwort-Format
```
[DATEI: pfad/zur/datei.py]
<nur ge√§nderte Zeilen oder minimaler Kontext>
  
[COMMAND]
<auszuf√ºhrende Befehle>
```
  
### Kommunikationsstil
- Pr√§zise und technisch korrekt
- Bei Unklarheiten: Eine gezielte R√ºckfrage statt Annahmen
- Fehlermeldungen vollst√§ndig zitieren bei Debugging
  
---
  
## üèÜ Code-Qualit√§t und Standards
  
### Python-Konventionen (PEP 8)
- **Zeilenl√§nge:** Maximal 100 Zeichen (konsistent mit Black/Flake8) [1]
- **Einr√ºckung:** 4 Spaces (keine Tabs) [1]
- **Imports:** Gruppiert und sortiert (stdlib ‚Üí third-party ‚Üí local) [1]
- **Namenskonventionen:**
  - `snake_case` f√ºr Funktionen, Variablen, Module [1]
  - `PascalCase` f√ºr Klassen [1]
  - `UPPER_SNAKE_CASE` f√ºr Konstanten [1]
  - `_private_prefix` f√ºr interne Funktionen/Variablen [1]
  
### DRY-Prinzip (Don't Repeat Yourself)
- Keine Code-Duplikation
- Gemeinsame Logik in Utils/Helper-Module auslagern
- Wiederverwendbare Komponenten identifizieren und extrahieren
  
### Linting und Formatierung
**EMPFOHLEN: Ruff (ersetzt Black, Flake8, isort)**
```toml
# Ruff Konfiguration (pyproject.toml) - Millisekunden statt Sekunden
[tool.ruff]
line-length = 100
target-version = "py38"

[tool.ruff.lint]
select = ["E", "F", "W", "I", "N", "UP", "B", "A", "C4", "SIM"]
ignore = ["E203", "E501", "W503", "E402", "F401"]
exclude = [".git", "__pycache__", "build", "dist", "venv", ".venv"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

**LEGACY: Black + Flake8 (nur wenn Ruff nicht m√∂glich)**
```toml
# Black Konfiguration (pyproject.toml)
[tool.black]
line-length = 100
target-version = ['py38', 'py39', 'py310', 'py311', 'py312']
  
[tool.isort]
profile = "black"
line_length = 100
```
  
### Type Hints
- Alle √∂ffentlichen Funktionen mit Type Hints versehen
- `typing` Modul f√ºr komplexe Typen nutzen
- MyPy-kompatibel schreiben
  
```python
from typing import Optional, List, Dict, Any
  
def process_data(
    items: List[str],
    config: Optional[Dict[str, Any]] = None
) -> Dict[str, int]:
    """Verarbeitet Daten und gibt Statistiken zur√ºck."""
    ...
```
  
### UTF-8 Konsistenz und Zeichenverwendung (KRITISCH)
- **Alle Dateien M√úSSEN UTF-8 kodiert sein** - ISO-8859 oder andere Kodierungen sind verboten
- **Kodierungsdeklaration:** F√ºge in jede Python-Datei `# -*- coding: utf-8 -*-` am Anfang hinzu
- **KEINE Sonderzeichen:** Verwende KEINE Umlaute (√§, √∂, √º, √ü) oder andere Nicht-ASCII-Zeichen in:
  - Code (Variablen, Funktionen, Klassen, Kommentare)
  - Dokumentation (Docstrings, README, Markdown-Dateien)
  - Log-Nachrichten
  - Konfigurationsdateien
  - Jeglichen Textdaten
- **KEINE Emojis:** Emojis sind in allen Dateien verboten
- **Nur Englisch:** Alle Texte (Code, Docs, Logs, Kommentare) M√úSSEN auf Englisch sein
- **Automatische Pr√ºfung:** Implementiere Linter-Checks (flake8, pre-commit Hooks) im Build-Prozess

```python
# CORRECT - English, no special characters
def process_user_data(user_id: int) -> dict:
    """Process user data and return statistics."""
    logger.info("Processing user data for user %s", user_id)
    return {"status": "success"}

# WRONG - German, umlauts, emojis
def verarbeite_benutzerdaten(benutzer_id: int) -> dict:
    """Verarbeitet Benutzerdaten und gibt Statistiken zur√ºck."""
    logger.info("Verarbeite Benutzerdaten f√ºr Benutzer %s üéâ", benutzer_id)
    return {"status": "erfolgreich"}
```
  
---

## ‚ö° Moderne Toolchain (uv, Ruff, Justfile)

### uv - Ultraschneller Package Manager
**Ersetzt pip/pip-tools f√ºr maximale Geschwindigkeit (10-100x schneller)**

```toml
# pyproject.toml - Dependency Management mit uv
[project]
name = "your-project"
version = "0.1.0"
requires-python = ">=3.8"
dependencies = [
    "django>=4.2",
    "httpx>=0.24",
    "pydantic>=2.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "ruff>=0.1.0",
    "mypy>=1.0",
]
```

**Workflow:**
```bash
# Installation (einmalig)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Projekt initialisieren
uv init

# Dependencies installieren (extrem schnell)
uv sync

# Einzelnes Paket hinzuf√ºgen
uv add httpx

# Dev-Dependencies hinzuf√ºgen
uv add --dev pytest ruff

# Skript ausf√ºhren
uv run python src/main.py
uv run pytest
```

### Ruff - All-in-One Linter & Formatter
**Ersetzt Black + Flake8 + isort + pyupgrade (100x schneller)**

```toml
# pyproject.toml - Vollst√§ndige Ruff-Konfiguration
[tool.ruff]
line-length = 100
target-version = "py38"
src = ["src", "tests"]

[tool.ruff.lint]
select = [
    "E",    # pycodestyle errors
    "F",    # pyflakes
    "W",    # pycodestyle warnings
    "I",    # isort
    "N",    # pep8-naming
    "UP",   # pyupgrade
    "B",    # flake8-bugbear
    "A",    # flake8-builtins
    "C4",   # flake8-comprehensions
    "SIM",  # flake8-simplify
]
ignore = ["E203", "E501", "W503", "E402", "F401"]

[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["F401"]
"tests/*" = ["S101"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
```

**Workflow:**
```bash
# Linting (Millisekunden)
uv run ruff check src tests

# Auto-Fix
uv run ruff check --fix src tests

# Formatierung pr√ºfen
uv run ruff format --check src tests

# Formatierung anwenden
uv run ruff format src tests
```

### Justfile - Task Runner
**Standardisiert alle Workflows und reduziert kognitive Last**

```just
# Justfile - Projekt-Root
set shell := ["bash", "-c"]
  
default:
    @just --list
  
# Initialisiert das Projekt (uv-basiert)
setup:
    uv sync
    cp -n .env.example .env || true
  
# Startet Dev-Umgebung (Schnelles Prototyping)
dev:
    bash docker/entrypoint.sh
  
# Formatiert Code (Ruff)
format:
    uv run ruff format src tests
    uv run ruff check --fix src tests
  
# Pr√ºft Code-Qualit√§t (Read-only)
lint:
    uv run ruff check src tests
    uv run ruff format --check src tests
  
# Type-Checking
typecheck:
    uv run mypy src
  
# F√ºhrt Tests aus
test:
    uv run pytest
  
# Vollst√§ndige Qualit√§tspr√ºfung (CI-Simulation)
check: lint typecheck test
  
# Startet Docker-Container (Deployment-Simulation)
docker-up:
    docker-compose up -d --build
    docker-compose logs -f
  
# Stoppt Docker-Container
docker-down:
    docker-compose down
  
# Bereinigt Artefakte
clean:
    find . -type d -name "__pycache__" -exec rm -rf {} +
    find . -type f -name "*.pyc" -delete
    rm -rf .pytest_cache .coverage htmlcov .ruff_cache
```

**Nutzung:**
```bash
# Projekt-Setup
just setup

# Entwicklung
just dev

# Code formatieren
just format

# Qualit√§tspr√ºfung
just check

# Einzelne Tasks
just lint
just test
```

### Pre-Commit Integration
**Automatische Checks vor jedem Commit (fast instantan mit Ruff)**

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.15
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
  
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

**Setup:**
```bash
# Installation
uv add --dev pre-commit

# Aktivierung
uv run pre-commit install

# Manueller Run
uv run pre-commit run --all-files
```

### Vorteile der Modernen Toolchain

**Geschwindigkeit:**
- `uv sync`: 10-100x schneller als `pip install`
- `ruff check`: 100x schneller als Flake8
- `ruff format`: 10-20x schneller als Black
- Pre-Commit: <1s statt 5-10s

**Einfachheit:**
- Eine Konfigurationsdatei (`pyproject.toml`) statt 5+ Dateien
- Ein Tool (`ruff`) statt 4+ Tools (Black, Flake8, isort, pyupgrade)
- Ein Command (`just check`) statt mehrere manuelle Befehle

**Konsistenz:**
- Justfile erzwingt gleiche Workflows f√ºr alle Entwickler
- Identische Checks lokal und in CI/CD
- Keine "works on my machine"-Probleme

---
  
## üê≥ Docker und Container-Verwaltung

### Port-Konventionen (KRITISCH)
- **VERMEIDE Standard-Ports** um Konflikte zu vermeiden:
  - ‚ùå NICHT verwenden: 80, 8080, 3000, 8001
  - ‚úÖ Verwende stattdessen: 8082-8099, 3001-3099, 5000-5099, 9000-9099
- **Immer gleiche interne und externe Ports verwenden** f√ºr einfachere Konfiguration und Debugging
- **Port-Mapping in docker-compose.yml:**

```yaml
# CORRECT - Same internal/external ports, non-standard
services:
  web:
    ports:
      - "8085:8085"  # Host:Container (same port)
  api:
    ports:
      - "8086:8086"
  frontend:
    ports:
      - "3005:3005"

# WRONG - Different ports
services:
  web:
    ports:
      - "8085:8000"  # Host:Container (different ports)

# WRONG - Standard ports
services:
  web:
    ports:
      - "80:8000"    # Conflict risk
      - "8080:8080"  # Conflict risk
```

### Startreihenfolge (KRITISCH)
**IMMER Justfile verwenden f√ºr standardisierte Workflows:**

1. **Entwicklung:** `just dev` (startet entrypoint.sh)
2. **Deployment-Test:** `just docker-up` (optional)

```bash
# CORRECT - Use Justfile commands
# Development (runs entrypoint.sh)
just dev

# Deployment testing only
just docker-up

# WRONG - Manual commands or Docker first
bash docker/entrypoint.sh  # Use 'just dev' instead
docker-compose up -d       # Use 'just docker-up' instead
```

**Debugging-Strategie (ohne Justfile):**
```bash
# Alternative: Separate terminals for faster debugging
# Terminal 1: Migrations (once)
python src/manage.py migrate

# Terminal 2: Server
python src/manage.py runserver 0.0.0.0:8000

# Terminal 3: Application (e.g., bot, worker)
python src/manage.py runbot
```

**Debugging-Strategie:**
- **Schnellste Feedback-Loop:** Separate Terminals (Server + App getrennt)
- **Integration-Tests:** `bash docker/entrypoint.sh` (simuliert Docker-Umgebung)
- **Deployment-Tests:** `docker-compose up` (vollst√§ndiger Container-Test)

### Tests in Entrypoint (EMPFOHLEN f√ºr Produktion)
**F√ºhre Tests nach Migrationen im entrypoint.sh aus** f√ºr Qualit√§tssicherung:

```bash
# entrypoint.sh - Nach Migrationen
echo "Running tests..."
python -m pytest tests/ -v --tb=short
echo "Tests passed."

# Dann Server starten
```

**Vorteile:**
- Sicherstellung, dass Code nach DB-√Ñnderungen funktioniert
- Fr√ºhzeitige Fehlererkennung in CI/CD
- Konsistente Testausf√ºhrung

**F√ºr Entwicklung:** Tests optional machen via Umgebungsvariable
```bash
if [ "$RUN_TESTS" = "true" ]; then
    python -m pytest tests/ -v --tb=short
fi
```

### Docker-Compose Best Practices
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8085:8085"  # Same internal/external port, non-standard
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8085/health"]
      interval: 10s
      timeout: 5s
      retries: 5
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/dbname

  db:
    image: postgres:15
    ports:
      - "5433:5432"  # Non-standard port to avoid conflicts
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
```

### Docker-Verzeichnisstruktur (KRITISCH)
- **Immer einen `docker/` Ordner erstellen** f√ºr alle Docker-bezogenen Dateien
- **Pflicht-Dateien im `docker/` Ordner:**
  - `entrypoint.sh` ‚Äì Startskript f√ºr Container (Migrations + Server + App)
  - `Dockerfile` ‚Äì Container-Build-Konfiguration
- **Struktur:**
```
docker/
‚îú‚îÄ‚îÄ Dockerfile          # Container-Build
‚îú‚îÄ‚îÄ entrypoint.sh       # Container-Entrypoint
‚îî‚îÄ‚îÄ .dockerignore       # (Optional) Build-Kontext optimieren
```

---

## üìÅ Projektstruktur und Organisation
  
### Standard-Verzeichnisstruktur
```
project_root/
‚îú‚îÄ‚îÄ src/                      # Hauptquellcode
‚îÇ   ‚îî‚îÄ‚îÄ package_name/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ cli.py            # CLI-Einstiegspunkt
‚îÇ       ‚îú‚îÄ‚îÄ core/             # Kernlogik
‚îÇ       ‚îú‚îÄ‚îÄ services/         # Business-Logik/Services
‚îÇ       ‚îú‚îÄ‚îÄ models/           # Datenmodelle
‚îÇ       ‚îî‚îÄ‚îÄ utils/            # Hilfsfunktionen
‚îú‚îÄ‚îÄ tests/                    # Alle Tests
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ conftest.py
‚îú‚îÄ‚îÄ data/                     # Datendateien (YAML, JSON, etc.)
‚îú‚îÄ‚îÄ configs/                  # Konfigurationsdateien
‚îú‚îÄ‚îÄ docs/                     # Dokumentation
‚îú‚îÄ‚îÄ scripts/                  # Hilfsskripte
‚îú‚îÄ‚îÄ .env.example              # Beispiel-Umgebungsvariablen
‚îú‚îÄ‚îÄ .flake8                   # Flake8-Konfiguration
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ mypy.ini                  # MyPy-Konfiguration
‚îú‚îÄ‚îÄ pyproject.toml            # Projekt-Konfiguration (PFLICHT)
‚îú‚îÄ‚îÄ pytest.ini                # Pytest-Konfiguration
‚îú‚îÄ‚îÄ requirements.txt          # Dependencies
‚îî‚îÄ‚îÄ README.md
```
  
### Pflicht-Dateien f√ºr jedes Projekt
- [ ] `pyproject.toml` ‚Äì Projekt-Metadaten und Tool-Konfiguration (PFLICHT)
- [ ] `Justfile` ‚Äì Task Runner f√ºr standardisierte Workflows (EMPFOHLEN)
- [ ] `.env.example` ‚Äì Dokumentation aller Umgebungsvariablen
- [ ] `.gitignore` ‚Äì Angepasst an Projekttyp
- [ ] `README.md` ‚Äì Setup und Nutzung
- [ ] `docker/entrypoint.sh` ‚Äì Container-Startskript
- [ ] `docker/Dockerfile` ‚Äì Container-Build-Konfiguration
- [ ] `.pre-commit-config.yaml` ‚Äì Pre-Commit Hooks (EMPFOHLEN)
  
### Modulares Design
- Klare Trennung von Concerns (Separation of Concerns)
- Jedes Modul hat eine einzelne Verantwortlichkeit
- Abh√§ngigkeiten flie√üen von au√üen nach innen (Dependency Inversion)
  
---
  
## ‚öôÔ∏è Implementierungsrichtlinien
  
### Feature-Vollst√§ndigkeit (KRITISCH)
Jedes Feature muss **100% komplett** sein:
  
1. **Datenmodelle:** Schemas, YAMLs, Datenbank-Modelle definiert
2. **Logik:** Service-Layer vollst√§ndig implementiert
3. **Integration:** CLI/API/UI verwendet die neue Logik
4. **Tests:** Unit-Tests f√ºr kritische Pfade
5. **Dokumentation:** Mindestens Docstrings
  
### Asynchrone Programmierung
- `async/await` f√ºr I/O-bound Operations
- `httpx` statt `requests` f√ºr async HTTP
- Django: `aget`, `afilter`, `acreate`, `aupdate_or_create`, `asave`
- Vermeiden von Blocking-Calls in async Kontexten
  
```python
import httpx
  
async def fetch_data(url: str) -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.json()
```
  
### Konfiguration
- **Umgebungsvariablen** f√ºr alle Secrets und umgebungsspezifische Werte
- **YAML/TOML** f√ºr strukturierte Konfiguration
- **Niemals** Secrets hardcoden
- `.env` Dateien f√ºr lokale Entwicklung
  
```python
import os
from dotenv import load_dotenv
  
load_dotenv()
  
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///db.sqlite3")
API_KEY = os.environ["API_KEY"]  # Pflicht - wirft Error wenn fehlt
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
```
  
### Datenvalidierung
- Input-Validierung an allen Schnittstellen (CLI, API, Datei-Parsing)
- Pydantic f√ºr komplexe Datenstrukturen
- Fr√ºhzeitig fehlschlagen mit klaren Fehlermeldungen
  
```python
from pydantic import BaseModel, validator
  
class Config(BaseModel):
    api_key: str
    max_retries: int = 3
    @validator('max_retries')
    def validate_retries(cls, v):
        if v < 0:
            raise ValueError('max_retries muss >= 0 sein')
        return v
```
  
---
  
## üîß Fehlerbehandlung und Debugging
  
### Robuste Error-Handling
```python
import logging
  
logger = logging.getLogger(__name__)
  
def process_file(filepath: str) -> dict:
    """Verarbeitet eine Datei mit robuster Fehlerbehandlung."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except FileNotFoundError:
        logger.error(f"Datei nicht gefunden: {filepath}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Ung√ºltiges JSON in {filepath}: {e}")
        raise ValueError(f"Ung√ºltiges JSON-Format: {e}") from e
    except Exception as e:
        logger.exception(f"Unerwarteter Fehler bei {filepath}")
        raise
    return data
```
  
### Logging-Standards
```python
import logging
  
# Configuration - ENGLISH ONLY, NO SPECIAL CHARACTERS
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
  
# Usage - ENGLISH ONLY
logger = logging.getLogger(__name__)
logger.debug("Debug information")
logger.info("Normal operation")
logger.warning("Warning occurred")
logger.error("Error occurred")
logger.exception("Error with stack trace")  # Only in except block

# WRONG - German, special characters
logger.info("Normale Operation")  # Don't use German
logger.error("Fehler aufgetreten")  # Don't use German
logger.warning("Warnung ‚ö†Ô∏è")  # Don't use emojis
```
  
### H√§ufige Probleme und L√∂sungen
  

  

  

  
---
  
## üîí Sicherheit
  
### API-Key und Secret Management
- **NIEMALS** Secrets in Code oder Git
- Alle Secrets via Umgebungsvariablen
- `.env` in `.gitignore`
- `.env.example` mit Platzhaltern dokumentieren
  
```bash
# .env.example
API_KEY=your-api-key-here
DATABASE_URL=postgresql://user:password@localhost/db
SECRET_KEY=generate-a-random-string
```
  
### Input-Sanitization
- Alle User-Inputs validieren und sanitizen
- SQL-Injection vermeiden (parametrisierte Queries, ORM)
- Path-Traversal-Angriffe verhindern
  
```python
import os
  
def safe_path(base_dir: str, user_input: str) -> str:
    """Verhindert Path-Traversal-Angriffe."""
    full_path = os.path.normpath(os.path.join(base_dir, user_input))
    if not full_path.startswith(os.path.normpath(base_dir)):
        raise ValueError("Ung√ºltiger Pfad")
    return full_path
```
  
### Web-Sicherheit (Django/Flask)
- `ALLOWED_HOSTS` restriktiv konfigurieren
- CSRF-Schutz aktiviert lassen
- Admin-URLs nicht unter `/admin/` exponieren
- `DEBUG = False` in Produktion
  
---
  
## üß™ Testing und CI/CD
  
### Test-Struktur
```
tests/
‚îú‚îÄ‚îÄ conftest.py              # Shared Fixtures
‚îú‚îÄ‚îÄ unit/                    # Unit-Tests (isoliert, schnell)
‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îî‚îÄ‚îÄ test_utils.py
‚îú‚îÄ‚îÄ integration/             # Integrations-Tests
‚îÇ   ‚îî‚îÄ‚îÄ test_api.py
‚îî‚îÄ‚îÄ e2e/                     # End-to-End-Tests
    ‚îî‚îÄ‚îÄ test_cli.py
```
  
### Pytest-Konfiguration
```ini
# pytest.ini
[pytest]
testpaths = tests
addopts =
    --verbose
    --strict-markers
    --tb=short
    --cov=src
    --cov-report=term-missing
    --cov-report=html
markers =
    unit: Unit-Tests
    integration: Integrations-Tests
    slow: Langsame Tests
    requires_api: Ben√∂tigt externe API
```
  
### Test-Best-Practices
```python
import pytest
  
# Fixtures f√ºr Wiederverwendbarkeit
@pytest.fixture
def sample_config():
    return {"api_key": "test-key", "timeout": 30}
  
# Parametrisierte Tests
@pytest.mark.parametrize("input,expected", [
    ("hello", "HELLO"),
    ("World", "WORLD"),
    ("", ""),
])
def test_uppercase(input, expected):
    assert input.upper() == expected
  
# Async Tests
@pytest.mark.asyncio
async def test_async_function():
    result = await async_function()
    assert result is not None
  
# Marker f√ºr selektive Ausf√ºhrung
@pytest.mark.slow
@pytest.mark.requires_api
def test_external_api():
    ...
```
  
### CI/CD-Pipeline (GitHub Actions Beispiel)

**EMPFOHLEN: Mit uv + Ruff (extrem schnell)**
```yaml
name: CI
  
on: [push, pull_request]
  
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install uv
        uses: astral-sh/setup-uv@v1
        with:
          version: "latest"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: uv sync --all-extras
      
      - name: Lint and format check
        run: |
          uv run ruff check src tests
          uv run ruff format --check src tests
      
      - name: Type check
        run: uv run mypy src
      
      - name: Run tests
        run: uv run pytest --cov --cov-fail-under=80
```

**LEGACY: Mit pip + Black + Flake8 (langsamer)**
```yaml
name: CI
  
on: [push, pull_request]
  
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      - name: Lint with flake8
        run: flake8 src tests
      - name: Check formatting with black
        run: black --check src tests
      - name: Type check with mypy
        run: mypy src
      - name: Run tests
        run: pytest --cov --cov-fail-under=80
```
  
---
  
## üìö Dokumentation
  
### Docstrings (Google-Style)
```python
def complex_function(
    param1: str,
    param2: int,
    optional: bool = False
) -> Dict[str, Any]:
    """Kurze Beschreibung der Funktion.
  
    L√§ngere Beschreibung wenn n√∂tig, die das Verhalten
    der Funktion genauer erkl√§rt.
  
    Args:
        param1: Beschreibung des ersten Parameters.
        param2: Beschreibung des zweiten Parameters.
        optional: Beschreibung des optionalen Parameters.
            Defaults to False.
  
    Returns:
        Ein Dictionary mit den Ergebnissen:
        - 'key1': Beschreibung
        - 'key2': Beschreibung
  
    Raises:
        ValueError: Wenn param2 negativ ist.
        FileNotFoundError: Wenn die Datei nicht existiert.
  
    Example:
        >>> result = complex_function("test", 42)
        >>> print(result['status'])
        'success'
    """
    ...
```
  
### README-Struktur
```markdown
# Projektname
  
Kurze Beschreibung des Projekts.
  
## Features
- Feature 1
- Feature 2
  
## Installation
  
```bash
pip install -r requirements.txt
```
  
## Konfiguration
  
Kopiere `.env.example` zu `.env` und f√ºlle die Werte aus.
  
## Nutzung
  
```bash
python main.py --help
```
  
## Entwicklung
  
```bash
# Tests ausf√ºhren
pytest
  
# Linting
flake8 src tests
```
  
---
  
## ‚úÖ Finale Pr√ºfung vor Abschluss
  
### Checkliste vor `attempt_completion`
  
**Code-Qualit√§t:**
- [ ] Code ist formatiert (Ruff oder Black/isort)
- [ ] Keine Linting-Fehler (Ruff oder Flake8)
- [ ] Type Hints vorhanden
- [ ] Docstrings f√ºr √∂ffentliche Funktionen
- [ ] Pre-Commit Hooks laufen durch (falls konfiguriert)
  
**Vollst√§ndigkeit:**
- [ ] Feature vollst√§ndig implementiert (Daten + Logik + Integration)
- [ ] Alle notwendigen Dateien erstellt/aktualisiert
- [ ] Imports korrekt
- [ ] Keine TODO/FIXME ohne Erkl√§rung hinterlassen

**Sprache und Zeichenverwendung:**
- [ ] Alle Texte auf Englisch (Code, Docs, Logs, Kommentare)
- [ ] Keine Sonderzeichen (√§, √∂, √º, √ü) verwendet
- [ ] Keine Emojis verwendet
- [ ] UTF-8 Kodierung in allen Dateien

**Docker und Deployment:**
- [ ] Keine Standard-Ports verwendet (80, 8080, 3000, 8001)
- [ ] Gleiche interne und externe Ports verwendet
- [ ] Python-Anwendung startet vor Docker-Containern
- [ ] Health-Checks implementiert
- [ ] docker/ Ordner existiert mit entrypoint.sh und Dockerfile
  
**Tests:**
- [ ] Neue Funktionalit√§t getestet (oder Test-Strategie dokumentiert)
- [ ] Bestehende Tests laufen noch durch
  
**Konfiguration:**
- [ ] Neue Umgebungsvariablen in `.env.example` dokumentiert
- [ ] Konfigurationsdateien aktualisiert
  
**Dokumentation:**
- [ ] README aktualisiert wenn n√∂tig
- [ ] Breaking Changes dokumentiert
  
**Sicherheit:**
- [ ] Keine Secrets im Code
- [ ] Input-Validierung vorhanden
- [ ] Keine offensichtlichen Sicherheitsl√ºcken
  
---
  
## üîÑ Versionierung
  
Diese Rules gelten f√ºr:
- Python 3.8+
- Django 4.x+ (wenn verwendet)
- Moderne async/await Patterns
  
**Version:** 3.0.0
**Letzte Aktualisierung:** 2026-02-04

**Changelog:**
- v3.0.0 (2026-02-04):
  - Added modern toolchain section (uv, Ruff, Justfile)
  - Replaced Black/Flake8/isort with Ruff (100x faster)
  - Replaced pip with uv (10-100x faster)
  - Added Justfile as recommended task runner
  - Updated CI/CD pipeline for uv + Ruff
  - Added pre-commit configuration
  - Consolidated all tool configs in pyproject.toml
  - Updated mandatory files checklist
- v2.2.0 (2026-02-04):
  - Added tests in entrypoint.sh after migrations (recommended for production)
- v2.1.0 (2026-02-04):
  - Added requirement for same internal/external ports in Docker
  - Added mandatory docker/ folder with entrypoint.sh and Dockerfile
  - Updated mandatory project files checklist
- v2.0.0 (2026-02-04):
  - Added strict language policy (English only)
  - Added character restrictions (no umlauts, no emojis)
  - Added Docker port conventions (avoid 80, 8080, 3000, 8001)
  - Added startup order requirements (Python app before Docker)
  - Enhanced UTF-8 encoding requirements
- v1.0.0 (2024-10): Initial version
